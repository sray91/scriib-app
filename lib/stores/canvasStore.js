import { create } from 'zustand';
import { createClient } from '@supabase/supabase-js';

export const useCanvasStore = create((set, get) => ({
  session: null,

  // Session management
  initializeSession: async () => {
    try {
      // Get user authentication
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
      const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

      if (!supabaseUrl || !supabaseAnonKey) {
        console.warn('Supabase environment variables not found');
        throw new Error('Supabase not configured');
      }

      const supabase = createClient(supabaseUrl, supabaseAnonKey);

      const { data: userData } = await supabase.auth.getUser();
      const userId = userData.user?.id || 'anonymous';

      // Initialize session with basic structure
      const newSession = {
        sessionId: `session-${Date.now()}`,
        userId: userId,

        // Intrinsic Context (automatically available to all blocks)
        intrinsicContext: {
          userVoiceAnalysis: null,
          trainingDocuments: [],
          trendingInsights: null,
          userPreferences: {
            visualStyle: 'modern',
            tone: 'professional'
          },
          pastPosts: []
        },

        // Dynamic Context (generated by blocks during session)
        dynamicContext: {
          ideas: [],
          hooks: [],
          themes: [],
          tone: null,
          targetAudience: null,
          generatedContent: [],
          visuals: [],
          ctas: []
        },

        // Session Memory
        conversationHistory: [],
        createdAt: new Date().toISOString()
      };

      set({ session: newSession });

      // Load user context data if authenticated
      if (userData.user) {
        await get().loadUserContext(userData.user.id);
      }

    } catch (error) {
      console.error('Failed to initialize session:', error);

      // Fallback to anonymous session
      const fallbackSession = {
        sessionId: `session-${Date.now()}`,
        userId: 'anonymous',
        intrinsicContext: {
          userVoiceAnalysis: {
            style: 'Professional',
            tone: 'Confident',
            commonTopics: ['leadership', 'productivity', 'career growth'],
            avgLength: 850,
            usesEmojis: true,
            usesHashtags: false,
            preferredFormats: ['story', 'insight', 'tips']
          },
          trainingDocuments: [],
          trendingInsights: null,
          userPreferences: {
            visualStyle: 'modern',
            tone: 'professional'
          },
          pastPosts: []
        },
        dynamicContext: {
          ideas: [],
          hooks: [],
          themes: [],
          tone: null,
          targetAudience: null,
          generatedContent: [],
          visuals: [],
          ctas: []
        },
        conversationHistory: [],
        createdAt: new Date().toISOString()
      };

      set({ session: fallbackSession });
    }
  },

  // Load user context data
  loadUserContext: async (userId) => {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
      );

      // Load user's past posts for voice analysis
      const { data: pastPosts } = await supabase
        .from('past_posts')
        .select('content, published_at, metrics')
        .eq('user_id', userId)
        .eq('platform', 'linkedin')
        .order('published_at', { ascending: false })
        .limit(20);

      // Load training documents
      const { data: trainingDocs } = await supabase
        .from('training_documents')
        .select('file_name, extracted_text, word_count')
        .eq('user_id', userId)
        .eq('processing_status', 'completed')
        .order('created_at', { ascending: false })
        .limit(10);

      // Analyze user voice if we have past posts
      let userVoiceAnalysis = null;
      if (pastPosts && pastPosts.length > 0) {
        // Simple voice analysis (in real implementation, this would call the API)
        userVoiceAnalysis = {
          style: 'Professional',
          tone: 'Confident',
          commonTopics: ['leadership', 'productivity', 'career growth'],
          avgLength: Math.round(pastPosts.reduce((sum, post) => sum + post.content.length, 0) / pastPosts.length),
          usesEmojis: pastPosts.some(post => /[\u{1F300}-\u{1F6FF}]/u.test(post.content)),
          usesHashtags: pastPosts.some(post => post.content.includes('#')),
          preferredFormats: ['story', 'insight', 'tips'],
          dataSource: 'past_posts',
          postsAnalyzed: pastPosts.length
        };
      }

      // Update session with loaded data
      set(state => ({
        session: {
          ...state.session,
          intrinsicContext: {
            ...state.session.intrinsicContext,
            userVoiceAnalysis,
            trainingDocuments: trainingDocs || [],
            pastPosts: pastPosts || []
          }
        }
      }));

    } catch (error) {
      console.error('Failed to load user context:', error);
    }
  },

  // Update session context
  updateDynamicContext: (updates) => {
    set(state => ({
      session: {
        ...state.session,
        dynamicContext: {
          ...state.session.dynamicContext,
          ...updates
        }
      }
    }));
  },

  // Add to conversation history
  addToHistory: (interaction) => {
    set(state => ({
      session: {
        ...state.session,
        conversationHistory: [
          ...state.session.conversationHistory,
          {
            timestamp: Date.now(),
            ...interaction
          }
        ]
      }
    }));
  },

  // Clear dynamic context (useful after compilation)
  clearDynamicContext: () => {
    set(state => ({
      session: {
        ...state.session,
        dynamicContext: {
          ideas: [],
          hooks: [],
          themes: [],
          tone: null,
          targetAudience: null,
          generatedContent: [],
          visuals: [],
          ctas: []
        }
      }
    }));
  },

  // --- Session Persistence ---

  // Save current session state
  saveSession: async (nodes, edges, isAutoSave = false) => {
    try {
      const { session } = get();
      if (!session) return;

      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
      );

      // Determine session name based on content
      let sessionName = 'Untitled Session';

      // Try to find a meaningful name from content
      if (session.dynamicContext.ideas?.length > 0) {
        // Use first few words of first idea
        const idea = session.dynamicContext.ideas[0].content;
        sessionName = idea.split(' ').slice(0, 5).join(' ') + '...';
      } else if (session.dynamicContext.generatedContent?.length > 0) {
        const content = session.dynamicContext.generatedContent[0].content;
        sessionName = content.split('\n')[0].substring(0, 30);
      } else if (nodes.length > 1) {
        sessionName = `Canvas with ${nodes.length} blocks`;
      }

      // Check if we already have a DB ID for this session (stored in session object)
      const existingDbId = session.dbId;

      const sessionData = {
        user_id: session.userId,
        name: sessionName,
        nodes: nodes,
        edges: edges,
        dynamic_context: session.dynamicContext,
        last_accessed: new Date().toISOString()
      };

      let result;

      if (existingDbId) {
        // Update existing session
        result = await supabase
          .from('canvas_sessions')
          .update(sessionData)
          .eq('id', existingDbId)
          .select()
          .single();
      } else {
        // Insert new session
        result = await supabase
          .from('canvas_sessions')
          .insert(sessionData)
          .select()
          .single();
      }

      if (result.error) throw result.error;

      // Update local session with DB ID if it was a new insert
      if (result.data && !existingDbId) {
        set(state => ({
          session: {
            ...state.session,
            dbId: result.data.id
          }
        }));
      }

      return { success: true, savedSession: result.data };

    } catch (error) {
      console.error('Failed to save session:', error);
      return { success: false, error };
    }
  },

  // Load a session from DB
  loadSession: async (sessionId) => {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
      );

      const { data, error } = await supabase
        .from('canvas_sessions')
        .select('*')
        .eq('id', sessionId)
        .single();

      if (error) throw error;

      // Reconstruct session object
      const loadedSession = {
        sessionId: `session-${Date.now()}`, // New runtime ID to avoid conflicts
        dbId: data.id,
        userId: data.user_id,
        intrinsicContext: get().session?.intrinsicContext || { userVoiceAnalysis: null, trainingDocuments: [], pastPosts: [] }, // Keep intrinsic
        dynamicContext: data.dynamic_context || {},
        conversationHistory: [], // Reset chat history for now as it's not fully persisted in structure yet
        createdAt: data.created_at
      };

      set({ session: loadedSession });

      return {
        success: true,
        nodes: data.nodes || [],
        edges: data.edges || []
      };

    } catch (error) {
      console.error('Failed to load session:', error);
      return { success: false, error };
    }
  },

  // Fetch session history list
  fetchHistory: async () => {
    try {
      const { session } = get();
      if (!session?.userId) return [];

      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
      );

      const { data, error } = await supabase
        .from('canvas_sessions')
        .select('id, name, last_accessed, nodes')
        .eq('user_id', session.userId)
        .order('last_accessed', { ascending: false });

      if (error) throw error;
      return data;

    } catch (error) {
      console.error('Failed to fetch history:', error);
      return [];
    }
  },

  // Delete a session
  deleteSession: async (sessionId) => {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
      );

      const { error } = await supabase
        .from('canvas_sessions')
        .delete()
        .eq('id', sessionId);

      if (error) throw error;
      return true;

    } catch (error) {
      console.error('Failed to delete session:', error);
      return false;
    }
  }
})); 