import { create } from 'zustand';
import { createClient } from '@supabase/supabase-js';

export const useCanvasStore = create((set, get) => ({
  session: null,
  
  // Session management
  initializeSession: async () => {
    try {
      // Get user authentication
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
      const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
      
      if (!supabaseUrl || !supabaseAnonKey) {
        console.warn('Supabase environment variables not found');
        throw new Error('Supabase not configured');
      }
      
      const supabase = createClient(supabaseUrl, supabaseAnonKey);
      
      const { data: userData } = await supabase.auth.getUser();
      const userId = userData.user?.id || 'anonymous';
      
      // Initialize session with basic structure
      const newSession = {
        sessionId: `session-${Date.now()}`,
        userId: userId,
        
        // Intrinsic Context (automatically available to all blocks)
        intrinsicContext: {
          userVoiceAnalysis: null,
          trainingDocuments: [],
          trendingInsights: null,
          userPreferences: {
            visualStyle: 'modern',
            tone: 'professional'
          },
          pastPosts: []
        },
        
        // Dynamic Context (generated by blocks during session)
        dynamicContext: {
          ideas: [],
          hooks: [],
          themes: [],
          tone: null,
          targetAudience: null,
          generatedContent: [],
          visuals: [],
          ctas: []
        },
        
        // Session Memory
        conversationHistory: [],
        createdAt: new Date().toISOString()
      };
      
      set({ session: newSession });
      
      // Load user context data if authenticated
      if (userData.user) {
        await get().loadUserContext(userData.user.id);
      }
      
    } catch (error) {
      console.error('Failed to initialize session:', error);
      
      // Fallback to anonymous session
      const fallbackSession = {
        sessionId: `session-${Date.now()}`,
        userId: 'anonymous',
        intrinsicContext: {
          userVoiceAnalysis: {
            style: 'Professional',
            tone: 'Confident',
            commonTopics: ['leadership', 'productivity', 'career growth'],
            avgLength: 850,
            usesEmojis: true,
            usesHashtags: false,
            preferredFormats: ['story', 'insight', 'tips']
          },
          trainingDocuments: [],
          trendingInsights: null,
          userPreferences: {
            visualStyle: 'modern',
            tone: 'professional'
          },
          pastPosts: []
        },
        dynamicContext: {
          ideas: [],
          hooks: [],
          themes: [],
          tone: null,
          targetAudience: null,
          generatedContent: [],
          visuals: [],
          ctas: []
        },
        conversationHistory: [],
        createdAt: new Date().toISOString()
      };
      
      set({ session: fallbackSession });
    }
  },
  
  // Load user context data
  loadUserContext: async (userId) => {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
      );
      
      // Load user's past posts for voice analysis
      const { data: pastPosts } = await supabase
        .from('past_posts')
        .select('content, published_at, metrics')
        .eq('user_id', userId)
        .eq('platform', 'linkedin')
        .order('published_at', { ascending: false })
        .limit(20);
      
      // Load training documents
      const { data: trainingDocs } = await supabase
        .from('training_documents')
        .select('file_name, extracted_text, word_count')
        .eq('user_id', userId)
        .eq('processing_status', 'completed')
        .order('created_at', { ascending: false })
        .limit(10);
      
      // Analyze user voice if we have past posts
      let userVoiceAnalysis = null;
      if (pastPosts && pastPosts.length > 0) {
        // Simple voice analysis (in real implementation, this would call the API)
        userVoiceAnalysis = {
          style: 'Professional',
          tone: 'Confident',
          commonTopics: ['leadership', 'productivity', 'career growth'],
          avgLength: Math.round(pastPosts.reduce((sum, post) => sum + post.content.length, 0) / pastPosts.length),
          usesEmojis: pastPosts.some(post => /[\u{1F300}-\u{1F6FF}]/u.test(post.content)),
          usesHashtags: pastPosts.some(post => post.content.includes('#')),
          preferredFormats: ['story', 'insight', 'tips'],
          dataSource: 'past_posts',
          postsAnalyzed: pastPosts.length
        };
      }
      
      // Update session with loaded data
      set(state => ({
        session: {
          ...state.session,
          intrinsicContext: {
            ...state.session.intrinsicContext,
            userVoiceAnalysis,
            trainingDocuments: trainingDocs || [],
            pastPosts: pastPosts || []
          }
        }
      }));
      
    } catch (error) {
      console.error('Failed to load user context:', error);
    }
  },
  
  // Update session context
  updateDynamicContext: (updates) => {
    set(state => ({
      session: {
        ...state.session,
        dynamicContext: {
          ...state.session.dynamicContext,
          ...updates
        }
      }
    }));
  },
  
  // Add to conversation history
  addToHistory: (interaction) => {
    set(state => ({
      session: {
        ...state.session,
        conversationHistory: [
          ...state.session.conversationHistory,
          {
            timestamp: Date.now(),
            ...interaction
          }
        ]
      }
    }));
  },

  // Clear dynamic context (useful after compilation)
  clearDynamicContext: () => {
    set(state => ({
      session: {
        ...state.session,
        dynamicContext: {
          ideas: [],
          hooks: [],
          themes: [],
          tone: null,
          targetAudience: null,
          generatedContent: [],
          visuals: [],
          ctas: []
        }
      }
    }));
  }
})); 