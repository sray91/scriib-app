'use client';

import React, { useState, useCallback, useEffect } from 'react';
import ReactFlow, { 
  MiniMap, 
  Controls, 
  Background, 
  useNodesState, 
  useEdgesState, 
  addEdge,
  ReactFlowProvider,
  Panel
} from 'reactflow';
import 'reactflow/dist/style.css';
import { Button } from "@/components/ui/button";
import { useToast } from "@/components/ui/use-toast";
import { Play, Plus, Brain, Fish, Image, Type } from 'lucide-react';
import { create } from 'zustand';
import { createClient } from '@supabase/supabase-js';

// Zustand store for canvas state
const useCanvasStore = create((set, get) => ({
  session: null,
  
  // Session management
  initializeSession: async () => {
    try {
      // Get user authentication
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
      const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
      
      if (!supabaseUrl || !supabaseAnonKey) {
        console.warn('Supabase environment variables not found');
        throw new Error('Supabase not configured');
      }
      
      const supabase = createClient(supabaseUrl, supabaseAnonKey);
      
      const { data: userData } = await supabase.auth.getUser();
      const userId = userData.user?.id || 'anonymous';
      
      // Initialize session with basic structure
      const newSession = {
        sessionId: `session-${Date.now()}`,
        userId: userId,
        
        // Intrinsic Context (automatically available to all blocks)
        intrinsicContext: {
          userVoiceAnalysis: null,
          trainingDocuments: [],
          trendingInsights: null,
          userPreferences: {
            visualStyle: 'modern',
            tone: 'professional'
          },
          pastPosts: []
        },
        
        // Dynamic Context (generated by blocks during session)
        dynamicContext: {
          ideas: [],
          hooks: [],
          themes: [],
          tone: null,
          targetAudience: null,
          generatedContent: []
        },
        
        // Session Memory
        conversationHistory: [],
        createdAt: new Date().toISOString()
      };
      
      set({ session: newSession });
      
      // Load user context data if authenticated
      if (userData.user) {
        await get().loadUserContext(userData.user.id);
      }
      
    } catch (error) {
      console.error('Failed to initialize session:', error);
      
      // Fallback to anonymous session
      const fallbackSession = {
        sessionId: `session-${Date.now()}`,
        userId: 'anonymous',
        intrinsicContext: {
          userVoiceAnalysis: {
            style: 'Professional',
            tone: 'Confident',
            commonTopics: ['leadership', 'productivity', 'career growth'],
            avgLength: 850,
            usesEmojis: true,
            usesHashtags: false,
            preferredFormats: ['story', 'insight', 'tips']
          },
          trainingDocuments: [],
          trendingInsights: null,
          userPreferences: {
            visualStyle: 'modern',
            tone: 'professional'
          },
          pastPosts: []
        },
        dynamicContext: {
          ideas: [],
          hooks: [],
          themes: [],
          tone: null,
          targetAudience: null,
          generatedContent: []
        },
        conversationHistory: [],
        createdAt: new Date().toISOString()
      };
      
      set({ session: fallbackSession });
    }
  },
  
  // Load user context data
  loadUserContext: async (userId) => {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
      );
      
      // Load user's past posts for voice analysis
      const { data: pastPosts } = await supabase
        .from('past_posts')
        .select('content, published_at, metrics')
        .eq('user_id', userId)
        .eq('platform', 'linkedin')
        .order('published_at', { ascending: false })
        .limit(20);
      
      // Load training documents
      const { data: trainingDocs } = await supabase
        .from('training_documents')
        .select('file_name, extracted_text, word_count')
        .eq('user_id', userId)
        .eq('processing_status', 'completed')
        .order('created_at', { ascending: false })
        .limit(10);
      
      // Analyze user voice if we have past posts
      let userVoiceAnalysis = null;
      if (pastPosts && pastPosts.length > 0) {
        // Simple voice analysis (in real implementation, this would call the API)
        userVoiceAnalysis = {
          style: 'Professional',
          tone: 'Confident',
          commonTopics: ['leadership', 'productivity', 'career growth'],
          avgLength: Math.round(pastPosts.reduce((sum, post) => sum + post.content.length, 0) / pastPosts.length),
          usesEmojis: pastPosts.some(post => /[\u{1F300}-\u{1F6FF}]/u.test(post.content)),
          usesHashtags: pastPosts.some(post => post.content.includes('#')),
          preferredFormats: ['story', 'insight', 'tips'],
          dataSource: 'past_posts',
          postsAnalyzed: pastPosts.length
        };
      }
      
      // Update session with loaded data
      set(state => ({
        session: {
          ...state.session,
          intrinsicContext: {
            ...state.session.intrinsicContext,
            userVoiceAnalysis,
            trainingDocuments: trainingDocs || [],
            pastPosts: pastPosts || []
          }
        }
      }));
      
    } catch (error) {
      console.error('Failed to load user context:', error);
    }
  },
  
  // Update session context
  updateDynamicContext: (updates) => {
    set(state => ({
      session: {
        ...state.session,
        dynamicContext: {
          ...state.session.dynamicContext,
          ...updates
        }
      }
    }));
  },
  
  // Add to conversation history
  addToHistory: (interaction) => {
    set(state => ({
      session: {
        ...state.session,
        conversationHistory: [
          ...state.session.conversationHistory,
          {
            timestamp: Date.now(),
            ...interaction
          }
        ]
      }
    }));
  }
}));

// Block Components
function IdeationBlock({ data, id }) {
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const { toast } = useToast();
  const { session, updateDynamicContext, addToHistory } = useCanvasStore();
  
  const handleSendMessage = async () => {
    if (!input.trim()) return;
    
    setIsLoading(true);
    const userMessage = input.trim();
    setInput('');
    
    // Add user message to block
    const newMessages = [...messages, { role: 'user', content: userMessage }];
    setMessages(newMessages);
    
    try {
      // Call the CoCreate API
      const response = await fetch('/api/cocreate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userMessage,
          action: 'create'
        }),
      });
      
      const result = await response.json();
      
      if (response.ok) {
        // Add AI response to block
        setMessages(prev => [...prev, { 
          role: 'assistant', 
          content: result.message 
        }]);
        
        // Update session context
        updateDynamicContext({
          ideas: [...(session?.dynamicContext?.ideas || []), {
            id: `idea-${Date.now()}`,
            content: result.updatedPost,
            source: 'ideation',
            blockId: id
          }]
        });
        
        // Add to history
        addToHistory({
          blockId: id,
          blockType: 'ideation',
          input: userMessage,
          output: result.updatedPost,
          context: session?.intrinsicContext
        });
        
        // Update block data
        data.onUpdate?.({ 
          content: result.updatedPost,
          lastGenerated: new Date().toISOString()
        });
        
        toast({
          title: "Idea generated!",
          description: "Content has been added to session context"
        });
      } else {
        throw new Error(result.error || 'Failed to generate content');
      }
    } catch (error) {
      console.error('Error generating content:', error);
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <div className="bg-white rounded-lg shadow-lg border-2 border-blue-200 min-w-[350px]">
      <div className="flex items-center gap-2 p-3 bg-blue-50 rounded-t-lg border-b">
        <Brain className="h-5 w-5 text-blue-600" />
        <span className="font-medium text-blue-800">Ideation</span>
      </div>
      
      <div className="p-4">
        {/* Chat Messages */}
        <div className="h-40 overflow-y-auto mb-4 space-y-2">
          {messages.map((message, index) => (
            <div key={index} className={`p-2 rounded text-sm ${
              message.role === 'user' 
                ? 'bg-blue-100 text-blue-800 ml-4' 
                : 'bg-gray-100 text-gray-800 mr-4'
            }`}>
              {message.content}
            </div>
          ))}
          {messages.length === 0 && (
            <div className="text-center text-gray-500 text-sm py-8">
              Start brainstorming ideas...
            </div>
          )}
        </div>
        
        {/* Input */}
        <div className="flex gap-2">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
            placeholder="What do you want to create?"
            className="flex-1 px-3 py-2 border rounded-md text-sm"
            disabled={isLoading}
          />
          <Button
            onClick={handleSendMessage}
            disabled={isLoading || !input.trim()}
            size="sm"
          >
            {isLoading ? '...' : 'Send'}
          </Button>
        </div>
      </div>
    </div>
  );
}

function HookBlock({ data, id }) {
  const [hooks, setHooks] = useState([]);
  const [isGenerating, setIsGenerating] = useState(false);
  const { toast } = useToast();
  const { session, updateDynamicContext, addToHistory } = useCanvasStore();
  
  const generateHooks = async () => {
    if (!session?.dynamicContext?.ideas?.length) {
      toast({
        title: "No ideas found",
        description: "Connect to an ideation block first",
        variant: "destructive",
      });
      return;
    }
    
    setIsGenerating(true);
    
    try {
      // Use the latest idea from connected ideation blocks
      const latestIdea = session.dynamicContext.ideas[session.dynamicContext.ideas.length - 1];
      
      const response = await fetch('/api/cocreate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userMessage: `Create 3 compelling hooks for this content: ${latestIdea.content}`,
          action: 'create'
        }),
      });
      
      const result = await response.json();
      
      if (response.ok) {
        // Parse hooks from response (simplified)
        const generatedHooks = [
          { id: 1, text: "Hook 1: " + result.updatedPost.substring(0, 100) + "..." },
          { id: 2, text: "Hook 2: " + result.updatedPost.substring(100, 200) + "..." },
          { id: 3, text: "Hook 3: " + result.updatedPost.substring(200, 300) + "..." }
        ];
        
        setHooks(generatedHooks);
        
        // Update session context
        updateDynamicContext({
          hooks: [...(session?.dynamicContext?.hooks || []), ...generatedHooks.map(h => ({
            id: `hook-${Date.now()}-${h.id}`,
            content: h.text,
            source: 'hook',
            blockId: id
          }))]
        });
        
        toast({
          title: "Hooks generated!",
          description: "3 new hooks added to session context"
        });
      }
    } catch (error) {
      console.error('Error generating hooks:', error);
      toast({
        title: "Error",
        description: "Failed to generate hooks",
        variant: "destructive",
      });
    } finally {
      setIsGenerating(false);
    }
  };
  
  return (
    <div className="bg-white rounded-lg shadow-lg border-2 border-green-200 min-w-[350px]">
      <div className="flex items-center gap-2 p-3 bg-green-50 rounded-t-lg border-b">
        <Fish className="h-5 w-5 text-green-600" />
        <span className="font-medium text-green-800">Hook Generator</span>
      </div>
      
      <div className="p-4">
        <div className="space-y-3 mb-4">
          {hooks.map((hook) => (
            <div key={hook.id} className="p-3 bg-green-50 rounded-lg border border-green-200">
              <div className="text-sm text-green-800">{hook.text}</div>
            </div>
          ))}
          {hooks.length === 0 && (
            <div className="text-center text-gray-500 text-sm py-8">
              No hooks generated yet
            </div>
          )}
        </div>
        
        <Button
          onClick={generateHooks}
          disabled={isGenerating}
          className="w-full"
          variant="outline"
        >
          {isGenerating ? 'Generating...' : 'Generate Hooks'}
        </Button>
      </div>
    </div>
  );
}

function VisualBlock({ data, id }) {
  const [generatedImage, setGeneratedImage] = useState(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const { toast } = useToast();
  const { session, updateDynamicContext } = useCanvasStore();
  
  const generateVisual = async () => {
    if (!session?.dynamicContext?.ideas?.length) {
      toast({
        title: "No content found",
        description: "Connect to content blocks first",
        variant: "destructive",
      });
      return;
    }
    
    setIsGenerating(true);
    
    try {
      const latestIdea = session.dynamicContext.ideas[session.dynamicContext.ideas.length - 1];
      
      const response = await fetch('/api/infogen/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: latestIdea.content.substring(0, 200),
          context: 'LinkedIn post visual',
          templateId: 5 // Listicle template
        }),
      });
      
      const result = await response.json();
      
      if (response.ok) {
        setGeneratedImage(result.imageUrl);
        
        // Update session context
        updateDynamicContext({
          visuals: [...(session?.dynamicContext?.visuals || []), {
            id: `visual-${Date.now()}`,
            url: result.imageUrl,
            type: 'infographic',
            source: 'visual',
            blockId: id
          }]
        });
        
        toast({
          title: "Visual generated!",
          description: "Infographic added to session context"
        });
      }
    } catch (error) {
      console.error('Error generating visual:', error);
      toast({
        title: "Error",
        description: "Failed to generate visual",
        variant: "destructive",
      });
    } finally {
      setIsGenerating(false);
    }
  };
  
  return (
    <div className="bg-white rounded-lg shadow-lg border-2 border-purple-200 min-w-[350px]">
      <div className="flex items-center gap-2 p-3 bg-purple-50 rounded-t-lg border-b">
        <Image className="h-5 w-5 text-purple-600" />
        <span className="font-medium text-purple-800">Visual Generator</span>
      </div>
      
      <div className="p-4">
        <div className="h-48 bg-gray-50 rounded-lg border-2 border-dashed border-gray-300 flex items-center justify-center mb-4">
          {generatedImage ? (
            <img 
              src={generatedImage} 
              alt="Generated visual" 
              className="max-h-full max-w-full object-contain rounded"
            />
          ) : (
            <div className="text-center text-gray-500">
              <Image className="h-12 w-12 mx-auto mb-2 opacity-50" />
              <div className="text-sm">No visual generated yet</div>
            </div>
          )}
        </div>
        
        <Button
          onClick={generateVisual}
          disabled={isGenerating}
          className="w-full"
          variant="outline"
        >
          {isGenerating ? 'Generating...' : 'Generate Visual'}
        </Button>
      </div>
    </div>
  );
}

function ContentBlock({ data, id }) {
  const [content, setContent] = useState('');
  const { session, updateDynamicContext } = useCanvasStore();
  
  const compileContent = () => {
    if (!session?.dynamicContext) return;
    
    const { ideas, hooks } = session.dynamicContext;
    const latestIdea = ideas?.[ideas.length - 1]?.content || '';
    const latestHook = hooks?.[hooks.length - 1]?.content || '';
    
    const compiledContent = `${latestHook}\n\n${latestIdea}`;
    setContent(compiledContent);
    
    // Update session context
    updateDynamicContext({
      generatedContent: [...(session?.dynamicContext?.generatedContent || []), {
        id: `content-${Date.now()}`,
        content: compiledContent,
        source: 'content',
        blockId: id
      }]
    });
  };
  
  return (
    <div className="bg-white rounded-lg shadow-lg border-2 border-orange-200 min-w-[350px]">
      <div className="flex items-center gap-2 p-3 bg-orange-50 rounded-t-lg border-b">
        <Type className="h-5 w-5 text-orange-600" />
        <span className="font-medium text-orange-800">Content Editor</span>
      </div>
      
      <div className="p-4">
        <textarea
          value={content}
          onChange={(e) => setContent(e.target.value)}
          placeholder="Compiled content will appear here..."
          className="w-full h-40 p-3 border rounded-md text-sm resize-none"
        />
        
        <div className="flex gap-2 mt-4">
          <Button
            onClick={compileContent}
            className="flex-1"
            variant="outline"
          >
            Compile From Blocks
          </Button>
        </div>
      </div>
    </div>
  );
}

// Custom Node Types
const nodeTypes = {
  ideationBlock: IdeationBlock,
  hookBlock: HookBlock,
  visualBlock: VisualBlock,
  contentBlock: ContentBlock,
};

// Main Canvas Component
const CoCreateCanvas = () => {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedNodes, setSelectedNodes] = useState([]);
  const { toast } = useToast();
  const { session, initializeSession } = useCanvasStore();
  
  useEffect(() => {
    initializeSession();
  }, []);
  
  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyPress = (e) => {
      // Delete selected nodes
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selectedNodes.length > 0) {
          setNodes(nds => nds.filter(node => !selectedNodes.includes(node.id)));
          setSelectedNodes([]);
        }
      }
      
      // Quick add shortcuts
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case '1':
            e.preventDefault();
            addNode('ideation');
            break;
          case '2':
            e.preventDefault();
            addNode('hook');
            break;
          case '3':
            e.preventDefault();
            addNode('visual');
            break;
          case '4':
            e.preventDefault();
            addNode('content');
            break;
          case 'Enter':
            e.preventDefault();
            if (!isLoading) {
              compilePost();
            }
            break;
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [selectedNodes, isLoading]);
  
  // Handle node selection
  const onSelectionChange = useCallback((elements) => {
    const nodeIds = elements.nodes.map(node => node.id);
    setSelectedNodes(nodeIds);
  }, []);
  
  const onConnect = useCallback((params) => {
    setEdges((eds) => addEdge(params, eds));
  }, [setEdges]);
  
  const addNode = (type) => {
    const newNode = {
      id: `${type}-${Date.now()}`,
      type: `${type}Block`,
      position: { x: Math.random() * 400, y: Math.random() * 400 },
      data: { 
        label: type,
        onUpdate: (updates) => {
          setNodes(nds => nds.map(node => 
            node.id === newNode.id 
              ? { ...node, data: { ...node.data, ...updates } }
              : node
          ));
        }
      },
    };
    
    setNodes((nds) => nds.concat(newNode));
  };
  
  const compilePost = async () => {
    if (!session?.dynamicContext) {
      toast({
        title: "No content to compile",
        description: "Create some content first",
        variant: "destructive",
      });
      return;
    }
    
    const { ideas, hooks, visuals, generatedContent } = session.dynamicContext;
    
    // Check if we have any content to compile
    const hasContent = ideas?.length > 0 || hooks?.length > 0 || generatedContent?.length > 0;
    if (!hasContent) {
      toast({
        title: "No content to compile",
        description: "Generate some content in the blocks first",
        variant: "destructive",
      });
      return;
    }
    
    setIsLoading(true);
    
    try {
      // Start compilation process
      toast({
        title: "Compiling post...",
        description: "Assembling content from connected blocks",
      });
      
      // Compile final post content
      let finalContent = '';
      
      // Add hook if available
      const latestHook = hooks?.[hooks.length - 1];
      if (latestHook) {
        finalContent += latestHook.content.replace(/^Hook \d+: /, '') + '\n\n';
      }
      
      // Add main content
      const latestIdea = ideas?.[ideas.length - 1];
      const latestGeneratedContent = generatedContent?.[generatedContent.length - 1];
      
      if (latestGeneratedContent) {
        finalContent += latestGeneratedContent.content;
      } else if (latestIdea) {
        finalContent += latestIdea.content;
      }
      
      // Prepare post data for Post Forge
      const postData = {
        content: finalContent.trim(),
        scheduled_time: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // Tomorrow at same time
        day_of_week: new Date(Date.now() + 24 * 60 * 60 * 1000).toLocaleDateString('en-US', { weekday: 'long' }),
        status: 'draft',
        platforms: { linkedin: true },
        scheduled: false,
        approver_id: null,
        ghostwriter_id: null,
        created_at: new Date().toISOString(),
        canvas_session_id: session.sessionId,
        compiled_from_blocks: {
          ideation: ideas?.length || 0,
          hooks: hooks?.length || 0,
          visuals: visuals?.length || 0,
          content: generatedContent?.length || 0,
          session_id: session.sessionId
        }
      };
      
      // Save to Post Forge database
      const response = await fetch('/api/posts/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(postData),
      });
      
      if (!response.ok) {
        // Try alternative approach - create post via Supabase directly
        const supabase = createClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL,
          process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
        );
        
        const { data: userData } = await supabase.auth.getUser();
        
        if (!userData.user) {
          throw new Error('Please log in to save posts');
        }
        
        const { data: savedPost, error } = await supabase
          .from('posts')
          .insert({
            content: postData.content,
            scheduled_time: postData.scheduled_time,
            day_of_week: postData.day_of_week,
            status: postData.status,
            scheduled: postData.scheduled,
            user_id: userData.user.id,
            created_at: postData.created_at
          })
          .select()
          .single();
        
        if (error) {
          throw error;
        }
        
        // Handle media files if we have visuals
        const latestVisual = visuals?.[visuals.length - 1];
        if (latestVisual && savedPost) {
          try {
            await supabase
              .from('post_media')
              .insert({
                post_id: savedPost.id,
                media_urls: [latestVisual.url],
                created_at: new Date().toISOString()
              });
          } catch (mediaError) {
            console.warn('Failed to save media:', mediaError);
          }
        }
        
        toast({
          title: "Post compiled successfully!",
          description: `Your post has been saved to Post Forge as a draft`,
        });
        
        // Log successful compilation
        console.log('Post compiled and saved:', {
          postId: savedPost.id,
          contentLength: finalContent.length,
          blocksUsed: {
            ideas: ideas?.length || 0,
            hooks: hooks?.length || 0,
            visuals: visuals?.length || 0,
            content: generatedContent?.length || 0
          }
        });
        
        return;
      }
      
      const result = await response.json();
      
      toast({
        title: "Post compiled successfully!",
        description: "Your post has been saved to Post Forge",
      });
      
      // Clear session context after successful compilation
      useCanvasStore.getState().updateDynamicContext({
        ideas: [],
        hooks: [],
        visuals: [],
        generatedContent: []
      });
      
         } catch (error) {
       console.error('Compilation failed:', error);
       toast({
         title: "Compilation failed",
         description: error.message || "Failed to save post to Post Forge",
         variant: "destructive",
       });
     } finally {
       setIsLoading(false);
     }
   };
  
  return (
    <div className="w-full h-screen">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        onSelectionChange={onSelectionChange}
        nodeTypes={nodeTypes}
        fitView
        multiSelectionKeyCode="Control"
        deleteKeyCode="Delete"
        selectNodesOnDrag={false}
      >
        <Controls />
        <MiniMap />
        <Background />
        
        {/* Top Panel */}
        <Panel position="top-right">
          <div className="flex gap-2">
            <Button 
              onClick={compilePost} 
              disabled={isLoading}
              className="bg-blue-600 hover:bg-blue-700"
            >
              <Play className="h-4 w-4 mr-2" />
              {isLoading ? 'Compiling...' : 'Compile Post'}
            </Button>
          </div>
        </Panel>
        
        {/* Block Library */}
        <Panel position="top-left">
          <div className="bg-white rounded-lg shadow-lg p-4">
            <h3 className="font-semibold mb-3">Add Blocks</h3>
            <div className="space-y-2">
              <Button
                onClick={() => addNode('ideation')}
                variant="outline"
                className="w-full justify-start"
              >
                <Brain className="h-4 w-4 mr-2" />
                Ideation
                <span className="ml-auto text-xs text-gray-500">⌘1</span>
              </Button>
              <Button
                onClick={() => addNode('hook')}
                variant="outline"
                className="w-full justify-start"
              >
                <Fish className="h-4 w-4 mr-2" />
                Hook
                <span className="ml-auto text-xs text-gray-500">⌘2</span>
              </Button>
              <Button
                onClick={() => addNode('visual')}
                variant="outline"
                className="w-full justify-start"
              >
                <Image className="h-4 w-4 mr-2" />
                Visual
                <span className="ml-auto text-xs text-gray-500">⌘3</span>
              </Button>
              <Button
                onClick={() => addNode('content')}
                variant="outline"
                className="w-full justify-start"
              >
                <Type className="h-4 w-4 mr-2" />
                Content
                <span className="ml-auto text-xs text-gray-500">⌘4</span>
              </Button>
            </div>
            
            <div className="mt-4 pt-4 border-t border-gray-200">
              <h4 className="font-medium text-sm mb-2">Shortcuts</h4>
              <div className="text-xs text-gray-600 space-y-1">
                <div>⌘↵ Compile Post</div>
                <div>⌫ Delete Selected</div>
                <div>Drag to Connect</div>
              </div>
            </div>
          </div>
        </Panel>
        
        {/* Session Context */}
        <Panel position="bottom-right">
          <div className="bg-white rounded-lg shadow-lg p-4 max-w-sm">
            <h3 className="font-semibold mb-3">Session Context</h3>
            
            {/* User Voice Analysis */}
            {session?.intrinsicContext?.userVoiceAnalysis && (
              <div className="mb-4">
                <h4 className="font-medium text-sm mb-2">Your Voice</h4>
                <div className="text-xs text-gray-600 space-y-1">
                  <div>Style: {session.intrinsicContext.userVoiceAnalysis.style}</div>
                  <div>Tone: {session.intrinsicContext.userVoiceAnalysis.tone}</div>
                  {session.intrinsicContext.userVoiceAnalysis.postsAnalyzed && (
                    <div>From {session.intrinsicContext.userVoiceAnalysis.postsAnalyzed} posts</div>
                  )}
                </div>
              </div>
            )}
            
            {/* Dynamic Context */}
            {session?.dynamicContext && (
              <div className="mb-4">
                <h4 className="font-medium text-sm mb-2">Generated Content</h4>
                <div className="text-sm space-y-2">
                  <div className="flex justify-between">
                    <span>Ideas:</span>
                    <span className="font-medium">{session.dynamicContext.ideas?.length || 0}</span>
                  </div>
                  <div className="flex justify-between">
                    <span>Hooks:</span>
                    <span className="font-medium">{session.dynamicContext.hooks?.length || 0}</span>
                  </div>
                  <div className="flex justify-between">
                    <span>Visuals:</span>
                    <span className="font-medium">{session.dynamicContext.visuals?.length || 0}</span>
                  </div>
                  <div className="flex justify-between">
                    <span>Content:</span>
                    <span className="font-medium">{session.dynamicContext.generatedContent?.length || 0}</span>
                  </div>
                </div>
              </div>
            )}
            
            {/* Canvas Stats */}
            <div className="pt-4 border-t border-gray-200">
              <h4 className="font-medium text-sm mb-2">Canvas</h4>
              <div className="text-xs text-gray-600 space-y-1">
                <div>Blocks: {nodes.length}</div>
                <div>Connections: {edges.length}</div>
                <div>Selected: {selectedNodes.length}</div>
              </div>
            </div>
          </div>
        </Panel>
      </ReactFlow>
    </div>
  );
};

export default function CoCreateCanvasWrapper() {
  return (
    <ReactFlowProvider>
      <CoCreateCanvas />
    </ReactFlowProvider>
  );
} 