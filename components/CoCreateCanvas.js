'use client';

import React, { useState, useCallback, useEffect } from 'react';
import ReactFlow, { 
  MiniMap, 
  Controls, 
  Background, 
  useNodesState, 
  useEdgesState, 
  addEdge,
  ReactFlowProvider,
  Panel
} from 'reactflow';
import 'reactflow/dist/style.css';
import { Button } from "@/components/ui/button";
import { useToast } from "@/components/ui/use-toast";
import { Play, Plus, Brain, Fish, Image, Type, Target, ChevronDown, X } from 'lucide-react';
import { create } from 'zustand';
import { createClient } from '@supabase/supabase-js';
import TemplateCard from '@/components/info-gen/TemplateCard';

// Zustand store for canvas state
const useCanvasStore = create((set, get) => ({
  session: null,
  
  // Session management
  initializeSession: async () => {
    try {
      // Get user authentication
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
      const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
      
      if (!supabaseUrl || !supabaseAnonKey) {
        console.warn('Supabase environment variables not found');
        throw new Error('Supabase not configured');
      }
      
      const supabase = createClient(supabaseUrl, supabaseAnonKey);
      
      const { data: userData } = await supabase.auth.getUser();
      const userId = userData.user?.id || 'anonymous';
      
      // Initialize session with basic structure
      const newSession = {
        sessionId: `session-${Date.now()}`,
        userId: userId,
        
        // Intrinsic Context (automatically available to all blocks)
        intrinsicContext: {
          userVoiceAnalysis: null,
          trainingDocuments: [],
          trendingInsights: null,
          userPreferences: {
            visualStyle: 'modern',
            tone: 'professional'
          },
          pastPosts: []
        },
        
        // Dynamic Context (generated by blocks during session)
        dynamicContext: {
          ideas: [],
          hooks: [],
          themes: [],
          tone: null,
          targetAudience: null,
          generatedContent: []
        },
        
        // Session Memory
        conversationHistory: [],
        createdAt: new Date().toISOString()
      };
      
      set({ session: newSession });
      
      // Load user context data if authenticated
      if (userData.user) {
        await get().loadUserContext(userData.user.id);
      }
      
    } catch (error) {
      console.error('Failed to initialize session:', error);
      
      // Fallback to anonymous session
      const fallbackSession = {
        sessionId: `session-${Date.now()}`,
        userId: 'anonymous',
        intrinsicContext: {
          userVoiceAnalysis: {
            style: 'Professional',
            tone: 'Confident',
            commonTopics: ['leadership', 'productivity', 'career growth'],
            avgLength: 850,
            usesEmojis: true,
            usesHashtags: false,
            preferredFormats: ['story', 'insight', 'tips']
          },
          trainingDocuments: [],
          trendingInsights: null,
          userPreferences: {
            visualStyle: 'modern',
            tone: 'professional'
          },
          pastPosts: []
        },
        dynamicContext: {
          ideas: [],
          hooks: [],
          themes: [],
          tone: null,
          targetAudience: null,
          generatedContent: []
        },
        conversationHistory: [],
        createdAt: new Date().toISOString()
      };
      
      set({ session: fallbackSession });
    }
  },
  
  // Load user context data
  loadUserContext: async (userId) => {
    try {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
      );
      
      // Load user's past posts for voice analysis
      const { data: pastPosts } = await supabase
        .from('past_posts')
        .select('content, published_at, metrics')
        .eq('user_id', userId)
        .eq('platform', 'linkedin')
        .order('published_at', { ascending: false })
        .limit(20);
      
      // Load training documents
      const { data: trainingDocs } = await supabase
        .from('training_documents')
        .select('file_name, extracted_text, word_count')
        .eq('user_id', userId)
        .eq('processing_status', 'completed')
        .order('created_at', { ascending: false })
        .limit(10);
      
      // Analyze user voice if we have past posts
      let userVoiceAnalysis = null;
      if (pastPosts && pastPosts.length > 0) {
        // Simple voice analysis (in real implementation, this would call the API)
        userVoiceAnalysis = {
          style: 'Professional',
          tone: 'Confident',
          commonTopics: ['leadership', 'productivity', 'career growth'],
          avgLength: Math.round(pastPosts.reduce((sum, post) => sum + post.content.length, 0) / pastPosts.length),
          usesEmojis: pastPosts.some(post => /[\u{1F300}-\u{1F6FF}]/u.test(post.content)),
          usesHashtags: pastPosts.some(post => post.content.includes('#')),
          preferredFormats: ['story', 'insight', 'tips'],
          dataSource: 'past_posts',
          postsAnalyzed: pastPosts.length
        };
      }
      
      // Update session with loaded data
      set(state => ({
        session: {
          ...state.session,
          intrinsicContext: {
            ...state.session.intrinsicContext,
            userVoiceAnalysis,
            trainingDocuments: trainingDocs || [],
            pastPosts: pastPosts || []
          }
        }
      }));
      
    } catch (error) {
      console.error('Failed to load user context:', error);
    }
  },
  
  // Update session context
  updateDynamicContext: (updates) => {
    set(state => ({
      session: {
        ...state.session,
        dynamicContext: {
          ...state.session.dynamicContext,
          ...updates
        }
      }
    }));
  },
  
  // Add to conversation history
  addToHistory: (interaction) => {
    set(state => ({
      session: {
        ...state.session,
        conversationHistory: [
          ...state.session.conversationHistory,
          {
            timestamp: Date.now(),
            ...interaction
          }
        ]
      }
    }));
  }
}));

// Block Components
function IdeationBlock({ data, id }) {
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [showDropdown, setShowDropdown] = useState(false);
  const { toast } = useToast();
  const { session, updateDynamicContext, addToHistory } = useCanvasStore();
  
  // Function to add connected block
  const addConnectedBlock = (blockType) => {
    // We'll need to access the canvas functions from here
    // For now, we'll trigger an event that the parent canvas can listen to
    const event = new CustomEvent('addConnectedBlock', {
      detail: { blockType, sourceId: id }
    });
    window.dispatchEvent(event);
    setShowDropdown(false);
  };
  
  const handleSendMessage = async () => {
    if (!input.trim()) return;
    
    setIsLoading(true);
    const userMessage = input.trim();
    setInput('');
    
    // Add user message to block
    const newMessages = [...messages, { role: 'user', content: userMessage }];
    setMessages(newMessages);
    
    try {
      // Call the CoCreate API
      const response = await fetch('/api/cocreate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userMessage,
          action: 'create'
        }),
      });
      
      const result = await response.json();
      
      if (response.ok) {
        // Add AI response to block
        setMessages(prev => [...prev, { 
          role: 'assistant', 
          content: result.message 
        }]);
        
        // Update session context
        updateDynamicContext({
          ideas: [...(session?.dynamicContext?.ideas || []), {
            id: `idea-${Date.now()}`,
            content: result.updatedPost,
            source: 'ideation',
            blockId: id
          }]
        });
        
        // Add to history
        addToHistory({
          blockId: id,
          blockType: 'ideation',
          input: userMessage,
          output: result.updatedPost,
          context: session?.intrinsicContext
        });
        
        // Update block data
        data.onUpdate?.({ 
          content: result.updatedPost,
          lastGenerated: new Date().toISOString()
        });
        
        toast({
          title: "Idea generated!",
          description: "Content has been added to session context"
        });
      } else {
        throw new Error(result.error || 'Failed to generate content');
      }
    } catch (error) {
      console.error('Error generating content:', error);
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <div className="bg-white rounded-lg shadow-lg border-2 border-blue-200 min-w-[350px] relative">
      <div className="flex items-center gap-2 p-3 bg-blue-50 rounded-t-lg border-b">
        <Brain className="h-5 w-5 text-blue-600" />
        <span className="font-medium text-blue-800">Ideation</span>
      </div>
      
      {/* Plus Button */}
      <div className="absolute -right-4 top-1/2 transform -translate-y-1/2">
        <div className="relative">
          <button
            onClick={() => setShowDropdown(!showDropdown)}
            className="w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center hover:bg-blue-600 transition-colors shadow-lg"
          >
            <Plus className="h-4 w-4" />
          </button>
          
          {/* Dropdown Menu */}
          {showDropdown && (
            <div className="absolute left-10 top-0 bg-white border border-gray-200 rounded-lg shadow-lg py-1 z-10 min-w-[120px]">
              <button
                onClick={() => addConnectedBlock('visual')}
                className="w-full px-3 py-2 text-left hover:bg-gray-100 flex items-center gap-2 text-sm"
              >
                <Image className="h-4 w-4 text-purple-600" />
                Visual
              </button>
              <button
                onClick={() => addConnectedBlock('hook')}
                className="w-full px-3 py-2 text-left hover:bg-gray-100 flex items-center gap-2 text-sm"
              >
                <Fish className="h-4 w-4 text-green-600" />
                Hook
              </button>
              <button
                onClick={() => addConnectedBlock('cta')}
                className="w-full px-3 py-2 text-left hover:bg-gray-100 flex items-center gap-2 text-sm"
              >
                <Target className="h-4 w-4 text-red-600" />
                CTA
              </button>
            </div>
          )}
        </div>
      </div>
      
      <div className="p-4">
        {/* Chat Messages */}
        <div className="h-40 overflow-y-auto mb-4 space-y-2">
          {messages.map((message, index) => (
            <div key={index} className={`p-2 rounded text-sm ${
              message.role === 'user' 
                ? 'bg-blue-100 text-blue-800 ml-4' 
                : 'bg-gray-100 text-gray-800 mr-4'
            }`}>
              {message.content}
            </div>
          ))}
          {messages.length === 0 && (
            <div className="text-center text-gray-500 text-sm py-8">
              Start brainstorming ideas...
            </div>
          )}
        </div>
        
        {/* Input */}
        <div className="flex gap-2">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
            placeholder="What do you want to create?"
            className="flex-1 px-3 py-2 border rounded-md text-sm"
            disabled={isLoading}
          />
          <Button
            onClick={handleSendMessage}
            disabled={isLoading || !input.trim()}
            size="sm"
          >
            {isLoading ? '...' : 'Send'}
          </Button>
        </div>
      </div>
    </div>
  );
}

function HookBlock({ data, id }) {
  const [hooks, setHooks] = useState([]);
  const [isGenerating, setIsGenerating] = useState(false);
  const { toast } = useToast();
  const { session, updateDynamicContext, addToHistory } = useCanvasStore();
  
  const handleClose = () => {
    if (data.onClose) {
      data.onClose();
    } else {
      // Fallback: dispatch custom event
      window.dispatchEvent(new CustomEvent('removeNode', { detail: { nodeId: id } }));
    }
  };
  
  const generateHooks = async () => {
    if (!session?.dynamicContext?.ideas?.length) {
      toast({
        title: "No ideas found",
        description: "Connect to an ideation block first",
        variant: "destructive",
      });
      return;
    }
    
    setIsGenerating(true);
    
    try {
      // Use the latest idea from connected ideation blocks
      const latestIdea = session.dynamicContext.ideas[session.dynamicContext.ideas.length - 1];
      
      const response = await fetch('/api/cocreate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userMessage: `Create 3 compelling hooks for this content: ${latestIdea.content}`,
          action: 'create'
        }),
      });
      
      const result = await response.json();
      
      if (response.ok) {
        // Parse hooks from response (simplified)
        const generatedHooks = [
          { id: 1, text: "Hook 1: " + result.updatedPost.substring(0, 100) + "..." },
          { id: 2, text: "Hook 2: " + result.updatedPost.substring(100, 200) + "..." },
          { id: 3, text: "Hook 3: " + result.updatedPost.substring(200, 300) + "..." }
        ];
        
        setHooks(generatedHooks);
        
        // Update session context
        updateDynamicContext({
          hooks: [...(session?.dynamicContext?.hooks || []), ...generatedHooks.map(h => ({
            id: `hook-${Date.now()}-${h.id}`,
            content: h.text,
            source: 'hook',
            blockId: id
          }))]
        });
        
        toast({
          title: "Hooks generated!",
          description: "3 new hooks added to session context"
        });
      }
    } catch (error) {
      console.error('Error generating hooks:', error);
      toast({
        title: "Error",
        description: "Failed to generate hooks",
        variant: "destructive",
      });
    } finally {
      setIsGenerating(false);
    }
  };
  
  return (
    <div className="bg-white rounded-lg shadow-lg border-2 border-green-200 min-w-[350px] resize overflow-auto">
      <div className="flex items-center gap-2 p-3 bg-green-50 rounded-t-lg border-b">
        <Fish className="h-5 w-5 text-green-600" />
        <span className="font-medium text-green-800">Hook Generator</span>
        <button
          onClick={handleClose}
          className="ml-auto p-1 hover:bg-green-100 rounded-full transition-colors"
          title="Close block"
        >
          <X className="h-4 w-4 text-green-600" />
        </button>
      </div>
      
      <div className="p-4">
        <div className="space-y-3 mb-4">
          {hooks.map((hook) => (
            <div key={hook.id} className="p-3 bg-green-50 rounded-lg border border-green-200">
              <div className="text-sm text-green-800">{hook.text}</div>
            </div>
          ))}
          {hooks.length === 0 && (
            <div className="text-center text-gray-500 text-sm py-8">
              No hooks generated yet
            </div>
          )}
        </div>
        
        <Button
          onClick={generateHooks}
          disabled={isGenerating}
          className="w-full"
          variant="outline"
        >
          {isGenerating ? 'Generating...' : 'Generate Hooks'}
        </Button>
      </div>
    </div>
  );
}

function VisualBlock({ data, id }) {
  const [generatedImage, setGeneratedImage] = useState(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [selectedTemplate, setSelectedTemplate] = useState(null);
  const [step, setStep] = useState(0); // 0: template selection, 1: content input, 2: generated result
  const [content, setContent] = useState('');
  const [context, setContext] = useState('');
  const { toast } = useToast();
  const { session, updateDynamicContext } = useCanvasStore();
  
  const handleClose = () => {
    if (data.onClose) {
      data.onClose();
    } else {
      window.dispatchEvent(new CustomEvent('removeNode', { detail: { nodeId: id } }));
    }
  };
  
  const templates = [
    { id: 1, title: "Myth vs. Fact", imageSrc: "/images/templates/myth-vs-fact.png" },
    { id: 2, title: "12 Info Blocks", imageSrc: "/images/templates/info-blocks.png" },
    { id: 3, title: "Cheat Sheet", imageSrc: "/images/templates/cheat-sheet.png" },
    { id: 4, title: "10 Brutal Truths", imageSrc: "/images/templates/brutal-truths.png" },
    { id: 5, title: "Listicle", imageSrc: "/images/templates/listicle.png" },
    { id: 6, title: "8 Radial Options", imageSrc: "/images/templates/radial-options.png" },
    { id: 7, title: "5 Lessons", imageSrc: "/images/templates/lessons.png" },
    { id: 8, title: "Roadmap", imageSrc: "/images/templates/roadmap.png" },
    { id: 9, title: "7 Things About Archetype", imageSrc: "/images/templates/archetype.png" },
  ];
  
  const handleTemplateSelect = (template) => {
    setSelectedTemplate(template);
    
    // Auto-populate content from connected ideation blocks
    if (session?.dynamicContext?.ideas?.length) {
      const latestIdea = session.dynamicContext.ideas[session.dynamicContext.ideas.length - 1];
      setContent(latestIdea.content.substring(0, 500));
      setContext('LinkedIn post visual');
    }
    
    setStep(1);
  };
  
  const generateVisual = async () => {
    if (!content.trim()) {
      toast({
        title: "Content required",
        description: "Please provide content for the visual",
        variant: "destructive",
      });
      return;
    }
    
    setIsGenerating(true);
    
    try {
      const response = await fetch('/api/infogen/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: content.trim(),
          context: context || 'LinkedIn post visual',
          templateId: selectedTemplate?.id || 5
        }),
      });
      
      const result = await response.json();
      
      if (response.ok) {
        setGeneratedImage(result.imageUrl);
        
        // Update session context
        updateDynamicContext({
          visuals: [...(session?.dynamicContext?.visuals || []), {
            id: `visual-${Date.now()}`,
            url: result.imageUrl,
            type: 'infographic',
            source: 'visual',
            blockId: id,
            templateId: selectedTemplate?.id,
            templateName: selectedTemplate?.title
          }]
        });
        
        setStep(2);
        
        toast({
          title: "Visual generated!",
          description: "Infographic added to session context"
        });
      } else {
        throw new Error(result.error || 'Failed to generate visual');
      }
    } catch (error) {
      console.error('Error generating visual:', error);
      toast({
        title: "Error",
        description: error.message || "Failed to generate visual",
        variant: "destructive",
      });
    } finally {
      setIsGenerating(false);
    }
  };
  
  const resetToTemplateSelection = () => {
    setStep(0);
    setSelectedTemplate(null);
    setContent('');
    setContext('');
    setGeneratedImage(null);
  };
  
  return (
    <div className="bg-white rounded-lg shadow-lg border-2 border-purple-200 w-[500px] resize overflow-auto">
      <div className="flex items-center gap-2 p-3 bg-purple-50 rounded-t-lg border-b">
        <Image className="h-5 w-5 text-purple-600" />
        <span className="font-medium text-purple-800">Visual Generator</span>
        {step > 0 && (
          <button
            onClick={resetToTemplateSelection}
            className="text-xs text-purple-600 hover:text-purple-800"
          >
            ‚Üê Back to templates
          </button>
        )}
        <button
          onClick={handleClose}
          className="ml-auto p-1 hover:bg-purple-100 rounded-full transition-colors"
          title="Close block"
        >
          <X className="h-4 w-4 text-purple-600" />
        </button>
      </div>
      
      <div className="p-4">
        {/* Template Selection */}
        {step === 0 && (
          <div className="space-y-4">
            <h3 className="text-sm font-medium text-gray-700">Choose a Template</h3>
            <div className="grid grid-cols-3 gap-2 max-h-96">
              {templates.map((template) => (
                <div 
                  key={template.id}
                  onClick={() => handleTemplateSelect(template)}
                  className="border rounded-lg overflow-hidden cursor-pointer hover:shadow-lg transition-shadow duration-200 bg-white"
                >
                  <div className="relative h-20">
                    {template.imageSrc ? (
                      <img 
                        src={template.imageSrc} 
                        alt={template.title}
                        className="w-full h-full object-cover"
                      />
                    ) : (
                      <div className="w-full h-full flex items-center justify-center bg-gray-100">
                        <div className="text-center p-1">
                          <div className="text-gray-500 text-lg">üìÑ</div>
                        </div>
                      </div>
                    )}
                  </div>
                  <div className="p-2">
                    <h3 className="font-medium text-gray-900 text-xs leading-tight">{template.title}</h3>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
        
        {/* Content Input */}
        {step === 1 && (
          <div className="space-y-4">
            <div>
              <p className="text-sm text-gray-600 mb-2">
                Template: <span className="font-medium">{selectedTemplate?.title}</span>
              </p>
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Content
              </label>
              <textarea
                value={content}
                onChange={(e) => setContent(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm resize-none"
                rows={4}
                placeholder="Enter content for your visual..."
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Context (optional)
              </label>
              <input
                type="text"
                value={context}
                onChange={(e) => setContext(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm"
                placeholder="e.g., LinkedIn post visual"
              />
            </div>
            
            <Button
              onClick={generateVisual}
              disabled={isGenerating || !content.trim()}
              className="w-full"
              variant="outline"
            >
              {isGenerating ? 'Generating...' : 'Generate Visual'}
            </Button>
          </div>
        )}
        
        {/* Generated Result */}
        {step === 2 && (
          <div className="space-y-4">
            <div className="bg-gray-50 rounded-lg p-4">
              {generatedImage ? (
                <img 
                  src={generatedImage} 
                  alt="Generated visual" 
                  className="w-full h-auto rounded"
                />
              ) : (
                <div className="text-center text-gray-500 py-8">
                  <Image className="h-12 w-12 mx-auto mb-2 opacity-50" />
                  <div className="text-sm">Visual generation in progress...</div>
                </div>
              )}
            </div>
            
            <div className="flex gap-2">
              <Button
                onClick={resetToTemplateSelection}
                variant="outline"
                className="flex-1"
              >
                New Visual
              </Button>
              {generatedImage && (
                <Button
                  onClick={() => window.open(generatedImage, '_blank')}
                  className="flex-1"
                >
                  Download
                </Button>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

function ContentBlock({ data, id }) {
  const [content, setContent] = useState('');
  const { session, updateDynamicContext } = useCanvasStore();
  
  const handleClose = () => {
    if (data.onClose) {
      data.onClose();
    } else {
      window.dispatchEvent(new CustomEvent('removeNode', { detail: { nodeId: id } }));
    }
  };
  
  const compileContent = () => {
    if (!session?.dynamicContext) return;
    
    const { ideas, hooks } = session.dynamicContext;
    const latestIdea = ideas?.[ideas.length - 1]?.content || '';
    const latestHook = hooks?.[hooks.length - 1]?.content || '';
    
    const compiledContent = `${latestHook}\n\n${latestIdea}`;
    setContent(compiledContent);
    
    // Update session context
    updateDynamicContext({
      generatedContent: [...(session?.dynamicContext?.generatedContent || []), {
        id: `content-${Date.now()}`,
        content: compiledContent,
        source: 'content',
        blockId: id
      }]
    });
  };
  
  return (
    <div className="bg-white rounded-lg shadow-lg border-2 border-orange-200 min-w-[350px] resize overflow-auto">
      <div className="flex items-center gap-2 p-3 bg-orange-50 rounded-t-lg border-b">
        <Type className="h-5 w-5 text-orange-600" />
        <span className="font-medium text-orange-800">Content Editor</span>
        <button
          onClick={handleClose}
          className="ml-auto p-1 hover:bg-orange-100 rounded-full transition-colors"
          title="Close block"
        >
          <X className="h-4 w-4 text-orange-600" />
        </button>
      </div>
      
      <div className="p-4">
        <textarea
          value={content}
          onChange={(e) => setContent(e.target.value)}
          placeholder="Compiled content will appear here..."
          className="w-full h-40 p-3 border rounded-md text-sm resize-none"
        />
        
        <div className="flex gap-2 mt-4">
          <Button
            onClick={compileContent}
            className="flex-1"
            variant="outline"
          >
            Compile From Blocks
          </Button>
        </div>
      </div>
    </div>
  );
}

function CTABlock({ data, id }) {
  const [ctas, setCtas] = useState([]);
  const [isGenerating, setIsGenerating] = useState(false);
  const { toast } = useToast();
  const { session, updateDynamicContext, addToHistory } = useCanvasStore();
  
  const handleClose = () => {
    if (data.onClose) {
      data.onClose();
    } else {
      window.dispatchEvent(new CustomEvent('removeNode', { detail: { nodeId: id } }));
    }
  };
  
  const generateCTA = async () => {
    if (!session?.dynamicContext?.ideas?.length) {
      toast({
        title: "No content found",
        description: "Connect to an ideation block first",
        variant: "destructive",
      });
      return;
    }
    
    setIsGenerating(true);
    
    try {
      const latestIdea = session.dynamicContext.ideas[session.dynamicContext.ideas.length - 1];
      
      const response = await fetch('/api/cocreate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userMessage: `Create 3 compelling call-to-action options for this content: ${latestIdea.content}. Focus on engagement, connection, and driving action.`,
          action: 'create'
        }),
      });
      
      const result = await response.json();
      
      if (response.ok) {
        const generatedCTAs = [
          { id: 1, text: "üí¨ What's your experience with this?" },
          { id: 2, text: "üîó Connect with me if you found this helpful!" },
          { id: 3, text: "üì© DM me for more insights like this" }
        ];
        
        setCtas(generatedCTAs);
        
        // Update session context
        updateDynamicContext({
          ctas: [...(session?.dynamicContext?.ctas || []), ...generatedCTAs.map(c => ({
            id: `cta-${Date.now()}-${c.id}`,
            content: c.text,
            source: 'cta',
            blockId: id
          }))]
        });
        
        toast({
          title: "CTAs generated!",
          description: "3 new call-to-action options added"
        });
      }
    } catch (error) {
      console.error('Error generating CTAs:', error);
      toast({
        title: "Error",
        description: "Failed to generate CTAs",
        variant: "destructive",
      });
    } finally {
      setIsGenerating(false);
    }
  };
  
  return (
    <div className="bg-white rounded-lg shadow-lg border-2 border-red-200 min-w-[350px] resize overflow-auto">
      <div className="flex items-center gap-2 p-3 bg-red-50 rounded-t-lg border-b">
        <Target className="h-5 w-5 text-red-600" />
        <span className="font-medium text-red-800">Call-to-Action</span>
        <button
          onClick={handleClose}
          className="ml-auto p-1 hover:bg-red-100 rounded-full transition-colors"
          title="Close block"
        >
          <X className="h-4 w-4 text-red-600" />
        </button>
      </div>
      
      <div className="p-4">
        <div className="space-y-3 mb-4">
          {ctas.map((cta) => (
            <div key={cta.id} className="p-3 bg-red-50 rounded-lg border border-red-200">
              <div className="text-sm text-red-800">{cta.text}</div>
            </div>
          ))}
          {ctas.length === 0 && (
            <div className="text-center text-gray-500 text-sm py-8">
              No CTAs generated yet
            </div>
          )}
        </div>
        
        <Button
          onClick={generateCTA}
          disabled={isGenerating}
          className="w-full"
          variant="outline"
        >
          {isGenerating ? 'Generating...' : 'Generate CTAs'}
        </Button>
      </div>
    </div>
  );
}

// Custom Node Types
const nodeTypes = {
  ideationBlock: IdeationBlock,
  hookBlock: HookBlock,
  visualBlock: VisualBlock,
  contentBlock: ContentBlock,
  ctaBlock: CTABlock,
};

// Main Canvas Component
const CoCreateCanvas = () => {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedNodes, setSelectedNodes] = useState([]);
  const { toast } = useToast();
  const { session, initializeSession } = useCanvasStore();
  
  useEffect(() => {
    initializeSession();
    
    // Add default ideation block
    const defaultIdeationBlock = {
      id: 'ideation-default',
      type: 'ideationBlock',
      position: { x: 100, y: 100 },
      data: { 
        label: 'ideation',
        onUpdate: (updates) => {
          setNodes(nds => nds.map(node => 
            node.id === 'ideation-default' 
              ? { ...node, data: { ...node.data, ...updates } }
              : node
          ));
        }
        // No onClose function for the default ideation block
      },
    };
    
    setNodes([defaultIdeationBlock]);
  }, []);
  
  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyPress = (e) => {
      // Delete selected nodes
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selectedNodes.length > 0) {
          setNodes(nds => nds.filter(node => !selectedNodes.includes(node.id)));
          setSelectedNodes([]);
        }
      }
      
      // Quick add shortcuts
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case '1':
            e.preventDefault();
            addNode('ideation');
            break;
          case '2':
            e.preventDefault();
            addNode('hook');
            break;
          case '3':
            e.preventDefault();
            addNode('visual');
            break;
          case '4':
            e.preventDefault();
            addNode('content');
            break;
          case 'Enter':
            e.preventDefault();
            if (!isLoading) {
              compilePost();
            }
            break;
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [selectedNodes, isLoading]);
  
  // Handle adding connected blocks
  useEffect(() => {
    const handleAddConnectedBlock = (event) => {
      const { blockType, sourceId } = event.detail;
      addConnectedBlock(blockType, sourceId);
    };
    
    const handleRemoveNode = (event) => {
      const { nodeId } = event.detail;
      removeNode(nodeId);
    };
    
    window.addEventListener('addConnectedBlock', handleAddConnectedBlock);
    window.addEventListener('removeNode', handleRemoveNode);
    return () => {
      window.removeEventListener('addConnectedBlock', handleAddConnectedBlock);
      window.removeEventListener('removeNode', handleRemoveNode);
    };
  }, []);
  
  // Handle node selection
  const onSelectionChange = useCallback((elements) => {
    const nodeIds = elements.nodes.map(node => node.id);
    setSelectedNodes(nodeIds);
  }, []);
  
  const onConnect = useCallback((params) => {
    setEdges((eds) => addEdge(params, eds));
  }, [setEdges]);
  
  const addNode = (type) => {
    const nodeId = `${type}-${Date.now()}`;
    const newNode = {
      id: nodeId,
      type: `${type}Block`,
      position: { x: Math.random() * 400, y: Math.random() * 400 },
      data: { 
        label: type,
        onUpdate: (updates) => {
          setNodes(nds => nds.map(node => 
            node.id === nodeId 
              ? { ...node, data: { ...node.data, ...updates } }
              : node
          ));
        },
        onClose: type !== 'ideation' ? () => removeNode(nodeId) : undefined
      },
    };
    
    setNodes((nds) => nds.concat(newNode));
  };
  
  const addConnectedBlock = (type, sourceId) => {
    // Find the source node to position the new block relative to it
    const sourceNode = nodes.find(node => node.id === sourceId);
    const sourcePosition = sourceNode ? sourceNode.position : { x: 100, y: 100 };
    
    const nodeId = `${type}-${Date.now()}`;
    const newNode = {
      id: nodeId,
      type: `${type}Block`,
      position: { 
        x: sourcePosition.x + 400, 
        y: sourcePosition.y + (Math.random() - 0.5) * 200 
      },
      data: { 
        label: type,
        onUpdate: (updates) => {
          setNodes(nds => nds.map(node => 
            node.id === nodeId 
              ? { ...node, data: { ...node.data, ...updates } }
              : node
          ));
        },
        onClose: () => removeNode(nodeId)
      },
    };
    
    // Add the new node
    setNodes((nds) => nds.concat(newNode));
    
    // Create connection from source to new node
    const newEdge = {
      id: `${sourceId}-${nodeId}`,
      source: sourceId,
      target: nodeId,
      type: 'default',
      animated: true,
    };
    
    setEdges((eds) => eds.concat(newEdge));
  };

  const removeNode = (nodeId) => {
    setNodes(nds => nds.filter(node => node.id !== nodeId));
    setEdges(eds => eds.filter(edge => edge.source !== nodeId && edge.target !== nodeId));
  };
  
  const compilePost = async () => {
    if (!session?.dynamicContext) {
      toast({
        title: "No content to compile",
        description: "Create some content first",
        variant: "destructive",
      });
      return;
    }
    
    const { ideas, hooks, visuals, generatedContent } = session.dynamicContext;
    
    // Check if we have any content to compile
    const hasContent = ideas?.length > 0 || hooks?.length > 0 || generatedContent?.length > 0;
    if (!hasContent) {
      toast({
        title: "No content to compile",
        description: "Generate some content in the blocks first",
        variant: "destructive",
      });
      return;
    }
    
    setIsLoading(true);
    
    try {
      // Start compilation process
      toast({
        title: "Compiling post...",
        description: "Assembling content from connected blocks",
      });
      
      // Compile final post content
      let finalContent = '';
      
      // Add hook if available
      const latestHook = hooks?.[hooks.length - 1];
      if (latestHook) {
        finalContent += latestHook.content.replace(/^Hook \d+: /, '') + '\n\n';
      }
      
      // Add main content
      const latestIdea = ideas?.[ideas.length - 1];
      const latestGeneratedContent = generatedContent?.[generatedContent.length - 1];
      
      if (latestGeneratedContent) {
        finalContent += latestGeneratedContent.content;
      } else if (latestIdea) {
        finalContent += latestIdea.content;
      }
      
      // Prepare post data for Post Forge
      const postData = {
        content: finalContent.trim(),
        scheduled_time: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // Tomorrow at same time
        day_of_week: new Date(Date.now() + 24 * 60 * 60 * 1000).toLocaleDateString('en-US', { weekday: 'long' }),
        status: 'draft',
        platforms: { linkedin: true },
        scheduled: false,
        approver_id: null,
        ghostwriter_id: null,
        created_at: new Date().toISOString(),
        canvas_session_id: session.sessionId,
        compiled_from_blocks: {
          ideation: ideas?.length || 0,
          hooks: hooks?.length || 0,
          visuals: visuals?.length || 0,
          content: generatedContent?.length || 0,
          session_id: session.sessionId
        }
      };
      
      // Save to Post Forge database
      const response = await fetch('/api/posts/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(postData),
      });
      
      if (!response.ok) {
        // Try alternative approach - create post via Supabase directly
        const supabase = createClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL,
          process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
        );
        
        const { data: userData } = await supabase.auth.getUser();
        
        if (!userData.user) {
          throw new Error('Please log in to save posts');
        }
        
        const { data: savedPost, error } = await supabase
          .from('posts')
          .insert({
            content: postData.content,
            scheduled_time: postData.scheduled_time,
            day_of_week: postData.day_of_week,
            status: postData.status,
            scheduled: postData.scheduled,
            user_id: userData.user.id,
            created_at: postData.created_at
          })
          .select()
          .single();
        
        if (error) {
          throw error;
        }
        
        // Handle media files if we have visuals
        const latestVisual = visuals?.[visuals.length - 1];
        if (latestVisual && savedPost) {
          try {
            await supabase
              .from('post_media')
              .insert({
                post_id: savedPost.id,
                media_urls: [latestVisual.url],
                created_at: new Date().toISOString()
              });
          } catch (mediaError) {
            console.warn('Failed to save media:', mediaError);
          }
        }
        
        toast({
          title: "Post compiled successfully!",
          description: `Your post has been saved to Post Forge as a draft`,
        });
        
        // Log successful compilation
        console.log('Post compiled and saved:', {
          postId: savedPost.id,
          contentLength: finalContent.length,
          blocksUsed: {
            ideas: ideas?.length || 0,
            hooks: hooks?.length || 0,
            visuals: visuals?.length || 0,
            content: generatedContent?.length || 0
          }
        });
        
        return;
      }
      
      const result = await response.json();
      
      toast({
        title: "Post compiled successfully!",
        description: "Your post has been saved to Post Forge",
      });
      
      // Clear session context after successful compilation
      useCanvasStore.getState().updateDynamicContext({
        ideas: [],
        hooks: [],
        visuals: [],
        generatedContent: []
      });
      
         } catch (error) {
       console.error('Compilation failed:', error);
       toast({
         title: "Compilation failed",
         description: error.message || "Failed to save post to Post Forge",
         variant: "destructive",
       });
     } finally {
       setIsLoading(false);
     }
   };
  
  return (
    <div className="w-full h-screen">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        onSelectionChange={onSelectionChange}
        nodeTypes={nodeTypes}
        fitView
        multiSelectionKeyCode="Control"
        deleteKeyCode="Delete"
        selectNodesOnDrag={false}
      >
        <Controls />
        <MiniMap />
        <Background />
        
        {/* Top Panel */}
        <Panel position="top-right">
          <div className="flex gap-2">
            <Button 
              onClick={compilePost} 
              disabled={isLoading}
              className="bg-blue-600 hover:bg-blue-700"
            >
              <Play className="h-4 w-4 mr-2" />
              {isLoading ? 'Compiling...' : 'Compile Post'}
            </Button>
          </div>
        </Panel>
        

        

      </ReactFlow>
    </div>
  );
};

export default function CoCreateCanvasWrapper() {
  return (
    <ReactFlowProvider>
      <CoCreateCanvas />
    </ReactFlowProvider>
  );
} 